ฉันจะวิทยาศาสตร์ได้อย่างไร
สมมติว่าคุณกำลังเปลี่ยนวิธีจัดการการอนุญาตในเว็บแอปขนาดใหญ่ การทดสอบสามารถช่วยชี้แนะการรีแฟคเตอร์ของคุณได้ แต่คุณต้องการเปรียบเทียบพฤติกรรมปัจจุบันและการปรับโครงสร้างใหม่ภายใต้ภาระงานจริงๆ

ต้องการ "นักวิทยาศาสตร์"

คลาส MyWidget 
  def  อนุญาตหรือไม่ ( ผู้ใช้) 
    ทดลอง =  นักวิทยาศาสตร์ :: เริ่มต้น ใหม่"เครื่องมือ-สิทธิ์" การทดลอง ใช้{ model . check_user? ( ผู้ใช้) . ถูกต้อง? } # วิธีการแบบเก่าทดลอง ลอง{ ผู้ใช้. สามารถ? ( :read , model ) } # วิธีใหม่ 
        
         

    การทดลอง วิ่ง
  จบ
สิ้น
ห่อuseบล็อกรอบพฤติกรรมเดิมของรหัสและตัดtryรอบการทำงานใหม่ experiment.runจะส่งคืนสิ่งที่useบล็อกกลับมาเสมอแต่มันทำสิ่งต่าง ๆ อยู่เบื้องหลัง:

มันตัดสินใจว่าจะเรียกใช้tryบล็อกหรือไม่
สุ่มลำดับการทำงานuseและtryบล็อก
วัดระยะเวลาของพฤติกรรมทั้งหมดเป็นวินาที
เปรียบเทียบผลลัพธ์ของtryกับผลลัพธ์ของuse,
กลืนและบันทึกข้อยกเว้นที่เกิดขึ้นในtryบล็อกเมื่อแทนที่raised, และ
เผยแพร่ข้อมูลทั้งหมดนี้
useบล็อกที่เรียกว่าการควบคุม tryบล็อกที่เรียกว่าผู้สมัคร

การสร้างการทดสอบนั้นใช้ถ้อยคำค่อนข้างมาก แต่เมื่อคุณรวมScientistโมดูลscienceผู้ช่วยจะสร้างการทดลองและโทรrunหาคุณ:

ต้องการ "นักวิทยาศาสตร์"

คลาส MyWidget 
  รวมถึง Scientist

  def  อนุญาต? ( ผู้ใช้) 
    วิทยาศาสตร์ "อนุญาตวิดเจ็ต"  ทำ | การทดลอง |
      การทดลอง ใช้{ model . check_user ( ผู้ใช้) ถูกต้อง? } # วิธีการแบบเก่าทดลอง ลอง{ ผู้ใช้. สามารถ? ( :read , model ) } # new way end # ส่งกลับค่าควบคุมend end    
           
     
  
ถ้าคุณไม่ประกาศtryบล็อคใดๆเครื่องจักรของ Scientist จะไม่ถูกเรียกใช้และค่าควบคุมจะถูกส่งคืนเสมอ

ทำให้วิทยาศาสตร์มีประโยชน์
ตัวอย่างข้างต้นจะทำงาน แต่จริงๆ แล้วพวกเขาไม่ได้ทำอะไรเลย tryบล็อกไม่ได้ทำงานและยังไม่มีผลการค้นหาได้รับการตีพิมพ์ แทนที่การใช้การทดสอบเริ่มต้นเพื่อควบคุมการดำเนินการและการรายงาน:

ต้องการ "นักวิทยาศาสตร์/การทดลอง"

class  MyExperiment 
  รวม Scientist :: Experiment

  attr_accessor  :name

  def  เริ่มต้น( ชื่อ) 
    @name  =  ชื่อ
  end

   เปิดใช้งาน
    def ? # ดู "การทดสอบเร่งความเร็ว" ด้านล่าง
    สิ้นสุดจริง
  

  def  ยก( การดำเนินงาน,  ข้อผิดพลาด) 
    # ดู "ในการเรียกกลับนักวิทยาศาสตร์" ด้านล่าง
    หน้า "การดำเนินการ ' # { การดำเนิน} ' ล้มเหลวด้วยข้อผิดพลาด ' # { ข้อผิดพลาด. ตรวจสอบ} " 
    ซุปเปอร์ # จะ re-ยก
  ท้าย

  def  publish ( ผลลัพธ์) 
    # ดู "การเผยแพร่ผลลัพธ์" ด้านล่าง
    p  ผลลัพธ์
  end 
end
เมื่อScientist::Experimentรวมอยู่ในคลาส คลาสนั้นจะตั้งค่าโดยอัตโนมัติเป็นการนำไปใช้โดยปริยายผ่านScientist::Experiment.set_default. การset_defaultโทรนี้จะถูกข้ามหากคุณรวมScientist::Experimentไว้ในโมดูล

ตอนนี้การโทรไปยังscienceผู้ช่วยจะโหลดอินสแตนซ์ของMyExperiment.

การควบคุมการเปรียบเทียบ
นักวิทยาศาสตร์เปรียบเทียบค่าควบคุมและค่าตัวเลือกโดยใช้==. หากต้องการลบล้างพฤติกรรมนี้ ใช้compareเพื่อกำหนดวิธีเปรียบเทียบค่าที่สังเกตได้แทน:

คลาส MyWidget 
  รวมถึง Scientist

  def  ผู้ใช้
    วิทยาศาสตร์ "ผู้ใช้"  ทำ | อี |
      อี ใช้{ ผู้ใช้. ทั้งหมด} # ผลตอบแทนกรณีผู้ใช้อีเมล ลอง{ UserService . list } # ส่งคืน UserService::User instances            
          

      อี เปรียบเทียบ ทำ | ควบคุม,  ผู้สมัคร |
        ควบคุม. แผนที่( & : เข้าสู่ระบบ) == ผู้สมัคร map ( & :login ) end end end end
      
    
  
เพิ่มบริบท
ผลลัพธ์ไม่ได้มีประโยชน์มากนักหากไม่มีวิธีการระบุ ใช้contextวิธีการเพื่อเพิ่มหรือเรียกบริบทสำหรับการทดสอบ:

วิทยาศาสตร์ "อนุญาตวิดเจ็ต"  ทำ | อี |
  อี บริบท:user => user   

  อี ใช้ {  model . check_user ( ผู้ใช้) ถูกต้อง? } จ. ลอง{ ผู้ใช้. สามารถ? ( :read , model ) } จบ 
      
contextใช้ Hash คีย์สัญลักษณ์ของข้อมูลเพิ่มเติม ข้อมูลที่มีอยู่ในExperiment#publishผ่านทางcontextวิธีการ หากคุณใช้ตัวscienceช่วยเป็นจำนวนมากในชั้นเรียน คุณสามารถระบุบริบทเริ่มต้นได้:

คลาส MyWidget 
  รวมถึง Scientist

  def  อนุญาต? ( ผู้ใช้) 
    วิทยาศาสตร์ "อนุญาตวิดเจ็ต"  ทำ | อี |
      อี บริบท:user => user   

      อี ใช้ {  model . check_user ( ผู้ใช้) ถูกต้อง? } จ. ลอง{ ผู้ใช้. สามารถ? ( :read , model ) } end end 
          
    
  

  def  ทำลาย
    วิทยาศาสตร์ "เครื่องมือทำลาย"  ทำ | อี |
      อี ใช้{ old_scary_destroy } อี ลอง{ new_safe_destroy } end end   
         
    
  

  def  default_scientist_context 
    {  :widget  =>  self  } 
  end 
end
widget-permissionsและwidget-destructionการทดลองทั้งสองจะมีความ:widgetสำคัญในบริบทของพวกเขา

ค่าติดตั้งแพง
หากการทดสอบต้องการการตั้งค่าที่มีราคาแพงซึ่งควรจะเกิดขึ้นเมื่อทำการทดสอบเท่านั้น ให้กำหนดด้วยbefore_runวิธีต่อไปนี้:

# รหัสภายใต้การทดสอบแก้ไขสิ่งนี้ในสถานที่ เราต้องการคัดลอกสำหรับ
รหัสผู้สมัคร # แต่เมื่อจำเป็นเท่านั้น: 
value_for_original_code  =  big_object 
value_for_new_code       =  nil

วิทยาศาสตร์ "แพงแต่คุ้ม"  ทำ | อี |
  อี before_run ทำvalue_for_new_code = big_object deep_copy ท้ายอี ใช้{ original_code ( value_for_original_code ) } อี ลอง{ new_code ( value_for_new_code ) } end 
      
  
     
     
รักษาความสะอาด
บางครั้งคุณไม่ต้องการเก็บค่าทั้งหมดไว้สำหรับการวิเคราะห์ในภายหลัง ตัวอย่างเช่น การทดสอบอาจส่งกลับUserอินสแตนซ์ แต่เมื่อค้นคว้าข้อมูลที่ไม่ตรงกัน สิ่งที่คุณสนใจก็คือการเข้าสู่ระบบ คุณสามารถกำหนดวิธีการล้างค่าเหล่านี้ในการทดสอบ:

คลาส MyWidget 
  รวมถึง Scientist

  def  ผู้ใช้
    วิทยาศาสตร์ "ผู้ใช้"  ทำ | อี |
      อี ใช้{ ผู้ใช้. ทั้งหมด} อี ลอง{ UserService . รายการ}   
         

      อี ทำสะอาด  | ค่า |
        ค่า. แผนที่( & : เข้าสู่ระบบ) จัดเรียงปลายปลายปลายปลาย
      
    
  
และค่าที่ทำความสะอาดนี้มีให้ในการสังเกตในผลลัพธ์ที่เผยแพร่ขั้นสุดท้าย:

class  MyExperiment 
  รวม Scientist :: Experiment

  # ...

  def  เผยแพร่( ผล) 
    ผล ควบคุม. ค่า# [<ผู้ใช้อลิซ> <ผมบ๊อบผู้ใช้> <ผู้ใช้แครอล>] ผล ควบคุม. cleaned_value # ["อลิซ", "บ๊อบ", "แครอล"] จบสิ้น         
     
  
โปรดทราบว่า#cleanวิธีการนี้จะยกเลิกบล็อกตัวล้างก่อนหน้าหากคุณเรียกใช้อีกครั้ง หากคุณจำเป็นต้องเข้าถึงบล็อกตัวทำความสะอาดที่กำหนดค่าไว้ในปัจจุบันด้วยเหตุผลบางประการScientist::Experiment#cleanerจะคืนค่าบล็อกนั้นโดยไม่ต้องกังวลใจอีกต่อไป (สิ่งนี้อาจไม่เกิดขึ้นในการใช้งานปกติ แต่มีประโยชน์หากคุณกำลังเขียน เช่น ตัวดำเนินการทดลองที่กำหนดเองซึ่งมีตัวทำความสะอาดเริ่มต้น)

ละเว้นไม่ตรงกัน
ในช่วงเริ่มต้นของการทดสอบ เป็นไปได้ว่าโค้ดบางส่วนของคุณมักจะสร้างความไม่ตรงกันด้วยเหตุผลที่คุณทราบและเข้าใจ แต่ยังไม่ได้แก้ไข แทนที่จะแสดงกรณีที่ทราบแล้วว่าไม่ตรงกันในเมตริกหรือการวิเคราะห์ของคุณเสมอ คุณสามารถบอกการทดสอบว่าจะเพิกเฉยหรือไม่จับคู่ที่ไม่ตรงกันโดยใช้ignoreวิธีการ คุณอาจรวมมากกว่าหนึ่งบล็อกหากจำเป็น:

def  ผู้ดูแลระบบ? ( ผู้ใช้) 
  วิทยาศาสตร์ "อนุญาตวิดเจ็ต"  ทำ | อี |
    อี ใช้{ model . check_user ( ผู้ใช้) ผู้ดูแลระบบ? } จ. ลอง{ ผู้ใช้. สามารถ? ( :admin , model ) }   
        

    อี ละเว้น {  ผู้ใช้. พนักงาน?  }  # ผู้ใช้คือพนักงาน ผู้ดูแลระบบในระบบใหม่
    เสมอe . ละเลย ทำ | ควบคุม,  ผู้สมัคร |
      # ระบบใหม่ยังไม่รองรับผู้ใช้ที่ยังไม่ยืนยัน: 
      ควบคุม && ! ผู้สมัคร && ! ผู้ใช้งาน ยืนยัน_อีเมล? ปลายปลายปลาย
    
  
บล็อกการละเว้นจะถูกเรียกก็ต่อเมื่อค่าไม่ตรงกัน หากข้อสังเกตหนึ่งทำให้เกิดข้อยกเว้นและอีกข้อสังเกตหนึ่งไม่ถือว่าไม่ตรงกันเสมอ หากการสังเกตทั้งสองมีข้อยกเว้นต่างกัน ก็ถือว่าไม่ตรงกัน

การเปิด/ปิดการทดสอบ
บางครั้งคุณไม่ต้องการให้การทดสอบทำงาน พูดว่าปิดการใช้งาน codepath ใหม่สำหรับทุกคนที่ไม่ใช่พนักงาน คุณสามารถปิดการทดสอบโดยการตั้งค่าการrun_ifบล็อก หากส่งคืนfalseการทดสอบจะส่งกลับค่าควบคุมเท่านั้น มิฉะนั้น จะเลื่อนไปตามenabled?วิธีที่กำหนดค่าของการทดสอบ

คลาส DashboardController 
  รวมถึง Scientist

  def  dashboard_items 
    science  "dashboard-items"  ทำ | อี |
      # ทำการทดลองนี้สำหรับพนักงาน
      เท่านั้นe . run_if  {  current_user . พนักงาน?  } 
      # ... 
  จบ
สิ้น
เร่งการทดลอง
ในฐานะนักวิทยาศาสตร์ คุณทราบดีว่าการปิดการทดลองของคุณเป็นสิ่งสำคัญเสมอ เพื่อไม่ให้เกิดอาละวาดและส่งผลให้ชาวบ้านมีโกยหน้าประตูบ้านคุณ ในการควบคุมว่าจะเปิดใช้งานการทดสอบหรือไม่ คุณต้องรวมenabled?วิธีการในScientist::Experimentการนำไปใช้ของคุณ

class  MyExperiment 
  รวม Scientist :: Experiment

  attr_accessor  :name ,  :percent_enabled

  def  เริ่มต้น( ชื่อ) 
    @name  =  ชื่อ
    @percent_enabled  =  100 
  end

   เปิดใช้งาน
    def ? percent_enabled > 0 && rand ( 100 ) < percent_enabled 
  end

  # ...

จบ
โค้ดนี้จะถูกเรียกใช้สำหรับทุกวิธีด้วยการทดสอบทุกครั้ง ดังนั้นโปรดระมัดระวังเกี่ยวกับประสิทธิภาพของโค้ด ตัวอย่างเช่น คุณสามารถจัดเก็บการทดสอบในฐานข้อมูล แต่รวมไว้ในแคชระดับต่างๆ เช่น memcache หรือ thread-locals ตามคำขอ

ประกาศผล
วิทยาศาสตร์จะดีอะไรหากคุณไม่สามารถเผยแพร่ผลงานของคุณได้

คุณต้องใช้publish(result)วิธีนี้และสามารถเผยแพร่ข้อมูลได้ตามที่คุณต้องการ ตัวอย่างเช่น ข้อมูลเวลาสามารถส่งข้อมูลไปยังกราไฟต์ และวางที่ไม่ตรงกันในคอลเล็กชันต่อยอดใน redis เพื่อการดีบักในภายหลัง

publishวิธีการจะได้รับScientist::Resultตัวอย่างที่เกี่ยวข้องกับScientist::Observations:

class  MyExperiment 
  รวม Scientist :: Experiment

  # ...

  def  เผยแพร่( ผลลัพธ์)

    # เก็บระยะเวลาสำหรับค่าควบคุม$
    statsd ระยะเวลา "วิทยาศาสตร์. # { ชื่อ} .control" ,  ผล ควบคุม. ระยะเวลา# สำหรับผู้สมัคร (เฉพาะคนแรก ดูที่ "ฝ่าฝืนกฎ" ด้านล่าง 
    $statsd . timing "science. #{ name } .candidate" , ผล. ผู้สมัคร. ก่อน. ระยะเวลา
      

    # และจำนวนสำหรับการแข่งขัน / ไม่สนใจ / ไม่ตรงกัน: 
    ถ้า ผล ตรงกัน? 
      $statsd . เพิ่มขึ้น"วิทยาศาสตร์. # { ชื่อ} .matched" elsif ผล ละเลย? 
      $statsd . เพิ่มขึ้น"วิทยาศาสตร์. # { ชื่อ} .ignored" อื่น$
      statsd เพิ่ม"วิทยาศาสตร์#{ ชื่อ} .mismatched" # สุดท้าย เก็บไม่ตรงกันใน redis เพื่อให้สามารถดึงข้อมูลและตรวจสอบ# ในภายหลัง สำหรับการดีบักและการวิจัย store_mismatch_data ( 
      
     
      
      
      ผลลัพธ์) 
    สิ้นสุด
  สิ้นสุด

  def  store_mismatch_data ( ผล) 
    น้ำหนักบรรทุก =  { 
      : ชื่อ            =>  ชื่อ, 
      : บริบท         =>  บริบท, 
      การควบคุม         =>  observation_payload ( ผล. ควบคุม) , 
      : ผู้สมัคร       =>  observation_payload ( ผล. ผู้สมัคร. ครั้งแรก) , 
      : execution_order  =>  ผล ข้อสังเกต แผนที่( & :name ) }
    

    ที่สำคัญ =  "วิทยาศาสตร์. # { ชื่อ} .mismatch" $
    Redis lpush  คีย์,  น้ำหนักบรรทุก$
    Redis ปุ่มltrim  , 0 , 1000 end  
  

  def  observation_payload ( สังเกต) 
    ถ้า สังเกต ที่ยกขึ้น? { : ยกเว้น=> การสังเกต ข้อยกเว้น ระดับ, : ข้อความ=> การสังเกต ข้อยกเว้น ข้อความ, : การติดตามย้อนหลัง=> การสังเกต ข้อยกเว้น ติดตามย้อนหลัง} อื่น{ # ดูที่หัวข้อ "การรักษาความสะอาด" ด้านบน: ค่า=> การสังเกต cleaned_value } สิ้นสุดสิ้นสุดสิ้นสุด
      
          
            
          
      
    
      
        
          
      
    
  
การทดสอบ
เมื่อเรียกใช้ชุดทดสอบ คุณควรทราบว่าผลการทดสอบตรงกันเสมอ เพื่อช่วยในการทดสอบ Scientist ได้กำหนดraise_on_mismatchesแอตทริบิวต์ class เมื่อคุณรวมScientist::Experiment. ทำเช่นนี้เฉพาะในชุดทดสอบของคุณ!

หากต้องการเพิ่มเมื่อไม่ตรงกัน:

class  MyExperiment 
  include  Scientist :: Experiment 
  # ... การนำไปใช้
end

การทดลองของฉัน ยก_on_mismatches  =  จริง
นักวิทยาศาสตร์จะยกScientist::Experiment::MismatchErrorข้อยกเว้นหากมีการสังเกตไม่ตรงกัน

ข้อผิดพลาดที่ไม่ตรงกันที่กำหนดเอง
วิธีสั่งให้นักวิทยาศาสตร์แจ้งข้อผิดพลาดที่กำหนดเองแทนค่าเริ่มต้นScientist::Experiment::MismatchError:

คลาส CustomMismatchError < นักวิทยาศาสตร์ :: การทดลอง :: MismatchError 
  def  to_s 
    message  =  "มีไม่ตรงกัน! นี่คือความแตกต่าง:"

    diffs  =  ผล ผู้สมัคร. แผนที่ทำ | ผู้สมัคร |
      diff ใหม่( ผล. ควบคุม, ผู้สมัคร) สิ้นสุด เข้าร่วม( " \ n " )  
    

    " #{ ข้อความ} \n #{ diffs } " 
  end 
end
วิทยาศาสตร์ "อนุญาตวิดเจ็ต"  ทำ | อี |
  อี ใช้{ รายงาน. พบ( ID ) } อี ลอง{ ReportService . ใหม่. ดึงข้อมูล( id ) }   
     

  อี ยก_ด้วย CustomMismatchError 
สิ้นสุด
ซึ่งช่วยให้สามารถประมวลผลล่วงหน้าในข้อความแสดงข้อผิดพลาดที่ไม่ตรงกันได้

การจัดการข้อผิดพลาด
ในรหัสผู้สมัคร
นักวิทยาศาสตร์ช่วยเหลือและติดตามข้อยกเว้นทั้งหมดที่เกิดขึ้นใน a tryหรือuseblock รวมถึงบางส่วนที่การช่วยเหลืออาจทำให้เกิดพฤติกรรมที่ไม่คาดคิด (เช่นSystemExitหรือScriptError) หากต้องการกู้คืนชุดข้อยกเว้นที่เข้มงวดมากขึ้น ให้แก้ไขRESCUESรายการ:

# เริ่มต้นคือ [ยกเว้น] 
นักวิทยาศาสตร์ :: สังเกต :: ช่วยเหลือ แทนที่[ StandardError ] 
หมดเวลา timer_clock: หากคุณกำลังแนะนำผู้สมัครที่อาจหมดเวลา โปรดใช้ความระมัดระวัง คำเตือนแม้ว่านักวิทยาศาสตร์จะช่วยเหลือข้อยกเว้นทั้งหมดที่เกิดขึ้นในกลุ่มตัวเลือก แต่ก็ไม่ได้ป้องกันคุณจากการหมดเวลา เนื่องจากการทำเช่นนี้จะซับซ้อน อาจต้องใช้รหัสผู้สมัครในงานพื้นหลังและติดตามเวลาของคำขอ เรารู้สึกว่าค่าใช้จ่ายของความซับซ้อนนี้มีค่ามากกว่าประโยชน์ที่ได้รับ ดังนั้นตรวจสอบให้แน่ใจว่าโค้ดของคุณไม่ทำให้เกิดการหมดเวลา ความเสี่ยงนี้สามารถลดลงได้โดยการเรียกใช้การทดสอบในเปอร์เซ็นต์ที่ต่ำ เพื่อให้ผู้ใช้สามารถ (เป็นไปได้มากที่สุด) ข้ามการทดสอบโดยรีเฟรชหน้าเว็บหากพวกเขาถึงระยะหมดเวลา ดูการเพิ่มการทดสอบด้านล่างสำหรับรายละเอียดวิธีกำหนดเปอร์เซ็นต์สำหรับการทดสอบของคุณ

ในการเรียกกลับของนักวิทยาศาสตร์
หากมีข้อยกเว้นถูกยกขึ้นภายในใด ๆ ของผู้ช่วยเหลือภายในวิทยาศาสตร์เหมือนpublish, compareหรือcleanที่raisedวิธีการที่เรียกว่ามีชื่อสัญลักษณ์ของการดำเนินการภายในที่ล้มเหลวและข้อยกเว้นที่ถูกยกขึ้น พฤติกรรมเริ่มต้นScientist::Defaultคือการเพิ่มข้อยกเว้นใหม่ เนื่องจากการดำเนินการนี้หยุดการทดสอบทั้งหมด จึงเป็นความคิดที่ดีที่จะจัดการกับข้อผิดพลาดนี้และดำเนินการต่อ เพื่อไม่ให้การทดสอบโดยรวมถูกยกเลิกทั้งหมด:

class  MyExperiment 
  รวม Scientist :: Experiment

  # ...

  def  ยก( การดำเนินงาน,  ข้อผิดพลาด) 
    InternalErrorTracker ติดตาม! "วิทยาศาสตร์ล้มเหลวใน#{ name } : #{ operation } " , error end end  
  
การดำเนินการที่อาจได้รับการจัดการที่นี่คือ:

:clean- มีข้อยกเว้นในcleanบล็อก
:compare- มีข้อยกเว้นในcompareบล็อก
:enabled- มีข้อยกเว้นในenabled?วิธีการ
:ignore- มีข้อยกเว้นในignoreบล็อก
:publish- มีข้อยกเว้นในpublishวิธีการ
:run_if- มีข้อยกเว้นในrun_ifบล็อก
การออกแบบการทดลอง
เนื่องจากenabled?และrun_ifกำหนดเมื่อผู้สมัครทำงาน จึงเป็นไปไม่ได้ที่จะรับประกันว่าจะเรียกใช้ทุกครั้ง ด้วยเหตุนี้ นักวิทยาศาสตร์จึงปลอดภัยสำหรับวิธีการห่อที่ไม่เปลี่ยนแปลงข้อมูลเท่านั้น

เมื่อใช้ Scientist เราพบว่าการแก้ไขทั้งระบบที่มีอยู่และระบบใหม่พร้อมๆ กันไม่ว่าจะเกิดขึ้นที่ใด และตรวจสอบผลลัพธ์ในเวลาที่อ่านด้วยscienceไฟล์ . raise_on_mismatchesยังมีประโยชน์ในการตรวจสอบให้แน่ใจว่าข้อมูลที่ถูกต้องถูกเขียนขึ้นในระหว่างการทดสอบ และการตรวจสอบการไม่ตรงกันที่เผยแพร่ได้ช่วยให้เราพบสถานการณ์ใดๆ ที่เรามองข้ามไปพร้อมกับข้อมูลการผลิตของเราในขณะใช้งานจริง เมื่อเขียนและอ่านจากสองระบบ การเขียนสคริปต์การกระทบยอดข้อมูลบางอย่างก็มีประโยชน์เช่นกัน เพื่อตรวจสอบและล้างข้อมูลการผลิตควบคู่ไปกับการทดลองที่ทำงานอยู่

อัตราเสียงรบกวนและข้อผิดพลาด
โปรดทราบว่านักวิทยาศาสตร์tryและuseบล็อกทำงานตามลำดับแบบสุ่ม ด้วยเหตุนี้ ข้อมูลใดๆ ที่โค้ดของคุณขึ้นอยู่กับอาจเปลี่ยนแปลงก่อนที่จะเรียกใช้บล็อกที่สอง ซึ่งอาจทำให้ค่าที่ส่งกลับไม่ตรงกันระหว่างตัวเลือกและค่าควบคุมที่ส่งกลับ ในการปรับเทียบความคาดหวังของคุณเกี่ยวกับผลลบลวงที่เกิดขึ้นจากสภาวะทางระบบภายนอกการเปลี่ยนแปลงที่คุณเสนอ ให้พิจารณาเริ่มต้นด้วยการทดสอบที่ทั้ง the tryและuseblock เรียกใช้วิธีการควบคุม จากนั้นดำเนินการแนะนำผู้สมัคร

สิ้นสุดการทดลอง
เมื่อพฤติกรรมของผู้สมัครมาบรรจบกับส่วนควบคุม คุณจะเริ่มคิดถึงการนำการทดสอบออกและใช้พฤติกรรมใหม่

หากมีบล็อกละเว้น พฤติกรรมของผู้สมัครจะรับประกันว่าจะแตกต่างกัน หากไม่สามารถยอมรับได้ คุณจะต้องลบบล็อกการละเว้นและแก้ไขพฤติกรรมที่ไม่ตรงกันอย่างต่อเนื่องจนกว่าการสังเกตจะตรงกันทุกครั้ง
เมื่อลบการทดสอบพฤติกรรมการอ่าน เป็นความคิดที่ดีที่จะรักษาการทำซ้ำด้านการเขียนระหว่างระบบเก่าและระบบใหม่ไว้จนกว่าจะถึงเวลาที่พฤติกรรมใหม่ได้เกิดขึ้นจริงแล้ว ในกรณีที่คุณจำเป็นต้องย้อนกลับ
แหกกฎ
บางครั้งนักวิทยาศาสตร์ก็ต้องทำอะไรแปลกๆ พวกเราเข้าใจ.

ละเลยผลลัพธ์โดยสิ้นเชิง
วิทยาศาสตร์มีประโยชน์แม้ว่าสิ่งที่คุณสนใจคือข้อมูลเวลา หรือแม้แต่เส้นทางรหัสใหม่จะระเบิดหรือไม่ก็ตาม หากคุณมีความสามารถในการควบคุมความถี่ที่การทดสอบทำงานผ่านenabled?วิธีการของคุณเพิ่มขึ้นคุณสามารถใช้การทดสอบนี้เพื่อทดสอบเส้นทางโค้ดใหม่อย่างเงียบๆ และละเว้นผลลัพธ์ทั้งหมด คุณสามารถทำได้โดยการตั้งค่าหรือให้มีประสิทธิภาพมากขึ้นignore { true }compare { true }

สิ่งนี้จะยังคงบันทึกไม่ตรงกันหากมีการยกข้อยกเว้นใดๆ แต่จะไม่สนใจค่าทั้งหมด

พยายามมากกว่าหนึ่งอย่าง
ไม่ควรลองมากกว่าหนึ่งทางเลือกพร้อมกัน ไม่รับประกันว่าพฤติกรรมจะแยกออกจากกัน และการรายงาน + การแสดงภาพจะยากขึ้นเล็กน้อย ถึงกระนั้นบางครั้งก็มีประโยชน์

หากต้องการลองมากกว่าหนึ่งทางเลือกในคราวเดียว ให้เพิ่มชื่อให้กับบางtryบล็อค:

ต้องการ "นักวิทยาศาสตร์"

คลาส MyWidget 
  รวมถึง Scientist

  def  อนุญาต? ( ผู้ใช้) 
    วิทยาศาสตร์ "อนุญาตวิดเจ็ต"  ทำ | อี |
      อี ใช้{ model . check_user ( ผู้ใช้) ถูกต้อง? } # ทางเก่า    

      อี ลอง( "API" )  {  ผู้ใช้ สามารถ? ( อ่าน, รุ่น) } # API บริการใหม่อี ลอง( "raw-sql" ) { ผู้ใช้. can_sql? ( :read , model ) } # raw query end end end   
           
    
  
เมื่อการทดสอบดำเนินไป พฤติกรรมของผู้สมัครทั้งหมดจะได้รับการทดสอบ และการสังเกตของผู้สมัครแต่ละครั้งจะถูกเปรียบเทียบกับกลุ่มควบคุมในทางกลับกัน

ไม่มีการควบคุม มีแต่ผู้สมัคร
กำหนดผู้สมัครด้วยtryบล็อกที่มีชื่อละเว้น a useและส่งชื่อผู้สมัครไปที่run:

ทดลอง =  MyExperiment ใหม่( "หลากหลายวิธี" ) ทำ | อี |
  อี ลอง( "ครั้งแรกทาง" ) { ... } อี ลอง( "วิธีที่สอง" ) { ... } end   
   


การทดลอง วิ่ง( "ทางที่สอง" )
scienceผู้ช่วยยังรู้เคล็ดลับนี้:

วิทยาศาสตร์ "หลากหลายวิธี" ,  วิ่ง : "ทางแรก"  ทำ | อี |
  อี ลอง( "ครั้งแรกทาง" ) { ... } อี ลอง( "วิธีที่สอง" ) { ... } end  
   
ให้ข้อมูลเวลาปลอม
หากคุณกำลังเขียนการทดสอบที่ขึ้นอยู่กับค่าเวลาที่เฉพาะเจาะจง คุณสามารถระบุระยะเวลาสำเร็จรูปโดยใช้fabricate_durations_for_testing_purposesวิธีการดังกล่าว และนักวิทยาศาสตร์จะรายงานสิ่งเหล่านี้Scientist::Observation#durationแทนเวลาดำเนินการจริง

วิทยาศาสตร์ "แน่นอน-ไม่มีอะไร-น่าสงสัย-เกิดขึ้นที่นี่"  ทำ | อี |
  อี ใช้{ ... } # "ควบคุม" e . ลอง{ ... } # "ผู้สมัคร" e . fabricate_durations_for_testing_purposes ( "control" => 1.0 , "candidate" => 0.5 ) สิ้นสุด  
    
         
fabricate_durations_for_testing_purposesรับค่าแฮชของระยะเวลา คีย์โดยชื่อพฤติกรรม (โดยค่าเริ่มต้น นักวิทยาศาสตร์ใช้"control"และ"candidate"แต่ถ้าคุณแทนที่สิ่งเหล่านี้ตามที่แสดงใน การลองมากกว่าหนึ่งสิ่งหรือไม่มีการควบคุมให้ใช้เฉพาะตัวเลือก ให้ใช้ชื่อที่ตรงกันที่นี่) หากไม่มีชื่อ เวลาดำเนินการจริงจะถูกรายงานแทน

เช่นScientist::Experiment#cleanerนี้อาจจะไม่เกิดขึ้นในการใช้งานปกติ อยู่ที่นี่เพื่อให้ง่ายต่อการทดสอบโค้ดที่ขยายขอบเขตของนักวิทยาศาสตร์

โดยไม่รวมนักวิทยาศาสตร์
หากคุณต้องการใช้ Scientist ในที่ที่คุณไม่สามารถรวมโมดูล Scientist ได้ คุณสามารถโทรScientist.run:

นักวิทยาศาสตร์ เรียกใช้ "การอนุญาตวิดเจ็ต"  ทำ | อี |
  อี ใช้{ model . check_user ( ผู้ใช้) ถูกต้อง? } จ. ลอง{ ผู้ใช้. สามารถ? ( :read , model ) } จบ   
      
การแฮ็ก
อยู่ในกล่อง Unixy ตรวจสอบให้แน่ใจว่า Bundler ที่ทันสมัยพร้อมใช้งาน script/testดำเนินการทดสอบหน่วย การพึ่งพาการพัฒนาทั้งหมดจะถูกติดตั้งโดยอัตโนมัติ นักวิทยาศาสตร์ต้องการ Ruby 2.3 หรือใหม่กว่า

ห่อ
RealGeeks/lab_techเป็นกลไกของ Rails สำหรับใช้ไลบรารีนี้โดยการควบคุม จัดเก็บ และวิเคราะห์ผลการทดลองด้วย ActiveRecord
ทางเลือก
daylerees / นักวิทยาศาสตร์ (PHP)
scienceproject/scientist.net (.NET)
joealcorn/ห้องปฏิบัติการ (Python)
รวบรวมข้อมูล238/Scientist4J (Java)
tomiaijo/นักวิทยาศาสตร์ (C++)
trello/นักวิทยาศาสตร์ (node.js)
ziyasal/scientist.js (node.js, ES6)
TrueWill/tzientist (node.js, TypeScript)
TrueWill / นักบรรพชีวินวิทยา (Deno, TypeScript)
ตะโกน/ห้องปฏิบัติการ (Clojure)
แลนซ์/นักวิทยาศาสตร์ (Perl 5)
แลนซ์/นักวิทยาศาสตร์P6 (Perl 6)
MadcapJake/Test-Lab (เพิร์ล 6)
cwbriones / นักวิทยาศาสตร์ (Elixir)
calavera / go-scientist (โก)
เจลเมอร์สโนค/ทดลอง (Go)
spoptchev/นักวิทยาศาสตร์ (Kotlin / Java)
เปียโนขยะ/นักวิทยาศาสตร์ (สวิฟต์)
นักวิทยาศาสตร์ไร้เซิร์ฟเวอร์ (AWS Lambda)
fightmegg/นักวิทยาศาสตร์ (TypeScript, เบราว์เซอร์ / Node.js)
ผู้ดูแล
